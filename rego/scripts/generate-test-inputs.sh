#!/usr/bin/env bash
# Copyright 2020-2021 Fugue, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
set -o nounset -o errexit -o pipefail

# Allow overriding terraform version.
TERRAFORM="${TERRAFORM:-terraform}"

function output_rego_file {
  local infra_file="$1"
  local rego_file="$2"
  cat <<EOF > "${rego_file}"
# Copyright 2020-2021 Fugue, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This package was automatically generated from:
#
#     ${infra_file}
#
# using 'generate_test_inputs.sh' and should not be modified
# directly.
#
EOF
  cat - >> "${rego_file}"
}

# the .rego files generated by generate_tf_input and generate_cfn_input look pretty
# similar right now, but we'll want to change the .rego file for tf inputs after we've
# added HCL support.
function generate_tf_input {
  local infra_file="$1"
  local rego_file="$2"
  local rego_dir=$(dirname "${rego_file}")
  local rego_basename=$(basename "${rego_file}" .rego)
  local plan_json_basename="${rego_basename}.tfplan"
  local plan_json="${rego_dir}/${plan_json_basename}"
  local workdir="$(mktemp -d)"
  trap "rm -rf "$workdir"" return

  cp "${infra_file}" "${workdir}"

  (cd "${workdir}" &&
    ${TERRAFORM} init &&
    ${TERRAFORM} plan -refresh=false -out="plan.tfplan" &&
    ${TERRAFORM} show -json "plan.tfplan" | jq > "${plan_json_basename}")
  
  cp "${workdir}/${plan_json_basename}" "${plan_json}"
  
  local package="$(echo "${rego_dir}.${rego_basename}" | tr '/' '.')"
  cat <<EOF | output_rego_file "${infra_file}" "${rego_file}"
# It provides three inputs for testing:
# - mock_input: The resource view input as passed to advanced rules
# - mock_resources: The resources present as a convenience for tests
# - mock_config: The raw config input as its parsed by regula
package ${package}

import data.regula

mock_config := regula_load_type("${plan_json_basename}", "tf-plan")
mock_input := regula.mock_input(mock_config)
mock_resources := mock_input.resources
EOF
}

function generate_cfn_input {
  local infra_file="$1"
  local rego_file="$2"
  local rego_dir=$(dirname "${rego_file}")
  local rego_basename=$(basename "${rego_file}" .rego)
  local config_basename=$(basename "${infra_file}")
  local package="$(echo "${rego_dir}.${rego_basename}" | tr '/' '.')"
  cat <<EOF | output_rego_file "${infra_file}" "${rego_file}"
# It provides three inputs for testing:
# - mock_input: The resource view input as passed to advanced rules
# - mock_resources: The resources present as a convenience for tests
# - mock_config: The raw config input as its parsed by regula
package ${package}

import data.regula

mock_config := regula_load_type("${config_basename}", "cfn")
mock_input := regula.mock_input(mock_config)
mock_resources := mock_input.resources
EOF
}

function generate_test_input {
  if [[ $# -ne 2 ]]; then
    1>&2 echo "Usage: $0 INFRA_FILE REGO_FILE"
    exit 1
  fi

  local infra_file="$1"
  local rego_file="$2"
  local extension="${infra_file##*.}"
  if [[ "${extension}" == "tf" ]]; then
    generate_tf_input "${infra_file}" "${rego_file}"
  elif [[ "${extension}" == "cfn" ]]; then
    generate_cfn_input "${infra_file}" "${rego_file}"
  else
    1>&2 echo "Unknown extension: $extension"
    exit 1
  fi

  1>&2 echo "Generated ${rego_file}"
}

if [[ $# -eq 0 ]]; then
  for infra_file in $(find tests -name '*_infra\.*'); do
    rego_file="$(echo "$infra_file" | sed 's/\.[^.]*$/.rego/')"
    if [[ ! -f "$rego_file" ]] || [[ "$infra_file" -nt "$rego_file" ]]; then
      1>&2 echo "$infra_file-> $rego_file"
      generate_test_input "$infra_file" "$rego_file"
    else
      1>&2 echo "$rego_file is up to date.  Remove it to force re-generating."
    fi
  done
elif [[ "$1" == "-h" || $# -gt 1 ]]; then
  1>&2 echo "Usage:"
  1>&2 echo "  $0             # Regenerates all test outputs"
  1>&2 echo "  $0 INFRA_FILE  # Regenerates a specific test output"
  exit 1
else
  infra_file="$1"
  rego_file="$(echo "$infra_file" | sed 's/\.[^.]*$/.rego/')"
  1>&2 echo "$infra_file-> $rego_file"
  generate_test_input "$infra_file" "$rego_file"
fi
